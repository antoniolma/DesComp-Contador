LDI $0		#Carrega o acumulador com o valor 0
STA @10     #Limpa LIMITE (unidades)
STA @11     #" LIMITE (dezenas)
STA @12     #" LIMITE (centenas)
STA @13     #" LIMITE (milhares)
STA @14     #" LIMITE (dezenas de m.)
STA @15     #" LIMITE (centenas de m.)
STA @16     #" LIMITE Contagem total
STA @17     #" Posicao para limite
STA @511	#" Leitura KEY0
STA @510	#" Leitura KEY1
STA @288	#" HEX0
STA @289	#" HEX1
STA @290	#" HEX2
STA @291	#" HEX3
STA @292	#" HEX4
STA @293	#" HEX5
STA @256	#" LDR0 ~ LDR7
STA @257	#" LDR8 
STA @258	#" LDR9
STA @0		#" MEM[0] (unidades)
STA @1		#" MEM[1] (dezenas)
STA @2		#" MEM[2] (centenas)
STA @3		#" MEM[3] (milhares)
STA @4		#" MEM[4] (dezenas de m.)
STA @5		#" MEM[5] (centenas de m.)
STA @18     # Constante 0
LDI $1
STA @19     # Constante 1
LDI $10
STA @20     # Constante 10
LDI $0      
STA @21     # Flag e inibir contagem
STA @6      #" Contagem total
STA @7      #" Posicao contagem
NOP         # INICIO LOOP PRINCIPAL ----------------------------------------- 
LDA @352
CEQ @18     
JEQ @41     # Se não foi pressionado, permanece no loop *************                   
JSR @42     # Se foi pressionado, entra na subrotina de incremento  *************
NOP
JMP @104     # *************
STA @511
LDA @0      # Carrega valor das unidades 
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @50     # Se for 10, pula para a casa das dezenas. Senão, atualiza o HEX0 com o próximo valor *************
STA @0      # Armazena valor incrementado
STA @288    # Carrega HEX0 com novo valor   
RET
LDI $0
STA @0
STA @288    # Carrega HEX0 com 0
LDA @1
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @60     # Se for 10, pula para a casa das centenas. Senão, atualiza o HEX1 com o próximo valor *************
STA @1      # Armazena valor incrementado
STA @289    # Carrega HEX1 com novo valor  
RET
LDI $0
STA @1
STA @289    # Carrega HEX1 com 0
LDA @2
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @70     # Se for 10, pula para a casa das unidades de milhares. Senão, atualiza o HEX2 com o próximo valor *************
STA @2      # Armazena valor incrementado
STA @290    # Carrega HEX2 com novo valor 
RET
LDI $0
STA @2      
STA @290    # Carrega HEX2 com 0
LDA @3
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @80     # Se for 10, pula para a casa das dezenas de milhares. Senão, atualiza o HEX3 com o próximo valor *************
STA @3      # Armazena valor incrementado
STA @291    # Carrega HEX3 com novo valor 
RET
LDI $0
STA @3      
STA @291    # Carrega HEX3 com 0
LDA @4
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @90     # Se for 10, pula para a casa das centenas de milhares. Senão, atualiza o HEX4 com o próximo valor *************
STA @4      # Armazena valor incrementado
STA @292    # Carrega HEX4 com novo valor 
RET
LDI $0
STA @4
STA @292    # Carrega HEX4 com 0
LDA @5
SOMA @19    # Soma com constante 1
CEQ @20     # Compara com a constante 10 para verificar o "vai 1"
JEQ @100    # Se for 10, ativa LED de OVERFLOW e flag de inibir contagem. Senão, atualiza o HEX5 com o próximo valor *************
STA @5      # Armazena valor incrementado
STA @293    # Carrega HEX5 com novo valor 
RET
LDI $1
STA @258    # Ativando LED de OVERFLOW (LDR9)
STA @21
RET
LDA @356    # LEITURA DO FPGA_RESET
CEQ @18     
JEQ @128    # Se não foi pressionado, permanece no loop e volta para o inicio *************                   
JSR @110    # Se foi pressionado, entra na subrotina de reset  *************
NOP
JMP @128
STA @510
LDI $0
STA @0
STA @1
STA @2
STA @3
STA @4
STA @5
STA @288	
STA @289	
STA @290	
STA @291	
STA @292	
STA @293	
STA @256	
STA @257	 
STA @258	
RET