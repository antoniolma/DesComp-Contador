tmp(0) := "00100" & "000" & '0' & x"00";	-- Carrega o acumulador com o valor 0
tmp(1) := "00101" & "000" & '0' & x"0A";	-- Limpa LIMITE (unidades)
tmp(2) := "00101" & "000" & '0' & x"0B";	-- " LIMITE (dezenas)
tmp(3) := "00101" & "000" & '0' & x"0C";	-- " LIMITE (centenas)
tmp(4) := "00101" & "000" & '0' & x"0D";	-- " LIMITE (milhares)
tmp(5) := "00101" & "000" & '0' & x"0E";	-- " LIMITE (dezenas de m.)
tmp(6) := "00101" & "000" & '0' & x"0F";	-- " LIMITE (centenas de m.)
tmp(7) := "00101" & "000" & '0' & x"10";	-- " LIMITE Contagem total
tmp(8) := "00101" & "000" & '0' & x"11";	-- " Posicao para limite
tmp(9) := "00101" & "000" & '1' & x"FF";	-- " Leitura KEY0
tmp(10) := "00101" & "000" & '1' & x"FE";	-- " Leitura KEY1
tmp(11) := "00101" & "000" & '1' & x"20";	-- " HEX0
tmp(12) := "00101" & "000" & '1' & x"21";	-- " HEX1
tmp(13) := "00101" & "000" & '1' & x"22";	-- " HEX2
tmp(14) := "00101" & "000" & '1' & x"23";	-- " HEX3
tmp(15) := "00101" & "000" & '1' & x"24";	-- " HEX4
tmp(16) := "00101" & "000" & '1' & x"25";	-- " HEX5
tmp(17) := "00101" & "000" & '1' & x"00";	-- " LDR0 ~ LDR7
tmp(18) := "00101" & "000" & '1' & x"01";	-- " LDR8
tmp(19) := "00101" & "000" & '1' & x"02";	-- " LDR9
tmp(20) := "00101" & "000" & '0' & x"00";	-- " MEM[0] (unidades)
tmp(21) := "00101" & "000" & '0' & x"01";	-- " MEM[1] (dezenas)
tmp(22) := "00101" & "000" & '0' & x"02";	-- " MEM[2] (centenas)
tmp(23) := "00101" & "000" & '0' & x"03";	-- " MEM[3] (milhares)
tmp(24) := "00101" & "000" & '0' & x"04";	-- " MEM[4] (dezenas de m.)
tmp(25) := "00101" & "000" & '0' & x"05";	-- " MEM[5] (centenas de m.)
tmp(26) := "00101" & "000" & '0' & x"12";	-- Constante 0
tmp(27) := "00100" & "000" & '0' & x"01";	-- LDI R0, $1
tmp(28) := "00101" & "000" & '0' & x"13";	-- Constante 1
tmp(29) := "00100" & "000" & '0' & x"0A";	-- LDI R0, $10
tmp(30) := "00101" & "000" & '0' & x"14";	-- Constante 10
tmp(31) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(32) := "00101" & "000" & '0' & x"15";	-- Flag e inibir contagem
tmp(33) := "00101" & "000" & '0' & x"06";	-- " Contagem total
tmp(34) := "00101" & "000" & '0' & x"07";	-- " Posicao contagem
tmp(35) := "00000" & "000" & '0' & x"00";	-- INICIO LOOP PRINCIPAL -----------------------------------------
tmp(36) := "00001" & "000" & '1' & x"60";	-- LDR R0, @352
tmp(37) := "01000" & "000" & '0' & x"12";	-- CEQ R0, @18
tmp(38) := "00111" & "000" & '0' & x"29";	-- Se não foi pressionado, permanece no loop *************
tmp(39) := "01001" & "000" & '0' & x"2A";	-- Se foi pressionado, entra na subrotina de incremento  *************
tmp(40) := "00000" & "000" & '0' & x"00";	-- NOP
tmp(41) := "00110" & "000" & '0' & x"68";	-- *************
tmp(42) := "00101" & "000" & '1' & x"FF";	-- STR R0, @511
tmp(43) := "00001" & "000" & '0' & x"00";	-- Carrega valor das unidades
tmp(44) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(45) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(46) := "00111" & "000" & '0' & x"32";	-- Se for 10, pula para a casa das dezenas. Senão, atualiza o HEX0 com o próximo valor *************
tmp(47) := "00101" & "000" & '0' & x"00";	-- Armazena valor incrementado
tmp(48) := "00101" & "000" & '1' & x"20";	-- Carrega HEX0 com novo valor
tmp(49) := "01010" & "000" & '0' & x"00";	-- RET
tmp(50) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(51) := "00101" & "000" & '0' & x"00";	-- STR R0, @0
tmp(52) := "00101" & "000" & '1' & x"20";	-- Carrega HEX0 com 0
tmp(53) := "00001" & "000" & '0' & x"01";	-- LDR R0, @1
tmp(54) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(55) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(56) := "00111" & "000" & '0' & x"3C";	-- Se for 10, pula para a casa das centenas. Senão, atualiza o HEX1 com o próximo valor *************
tmp(57) := "00101" & "000" & '0' & x"01";	-- Armazena valor incrementado
tmp(58) := "00101" & "000" & '1' & x"21";	-- Carrega HEX1 com novo valor
tmp(59) := "01010" & "000" & '0' & x"00";	-- RET
tmp(60) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(61) := "00101" & "000" & '0' & x"01";	-- STR R0, @1
tmp(62) := "00101" & "000" & '1' & x"21";	-- Carrega HEX1 com 0
tmp(63) := "00001" & "000" & '0' & x"02";	-- LDR R0, @2
tmp(64) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(65) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(66) := "00111" & "000" & '0' & x"46";	-- Se for 10, pula para a casa das unidades de milhares. Senão, atualiza o HEX2 com o próximo valor *************
tmp(67) := "00101" & "000" & '0' & x"02";	-- Armazena valor incrementado
tmp(68) := "00101" & "000" & '1' & x"22";	-- Carrega HEX2 com novo valor
tmp(69) := "01010" & "000" & '0' & x"00";	-- RET
tmp(70) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(71) := "00101" & "000" & '0' & x"02";	-- STR R0, @2
tmp(72) := "00101" & "000" & '1' & x"22";	-- Carrega HEX2 com 0
tmp(73) := "00001" & "000" & '0' & x"03";	-- LDR R0, @3
tmp(74) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(75) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(76) := "00111" & "000" & '0' & x"50";	-- Se for 10, pula para a casa das dezenas de milhares. Senão, atualiza o HEX3 com o próximo valor *************
tmp(77) := "00101" & "000" & '0' & x"03";	-- Armazena valor incrementado
tmp(78) := "00101" & "000" & '1' & x"23";	-- Carrega HEX3 com novo valor
tmp(79) := "01010" & "000" & '0' & x"00";	-- RET
tmp(80) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(81) := "00101" & "000" & '0' & x"03";	-- STR R0, @3
tmp(82) := "00101" & "000" & '1' & x"23";	-- Carrega HEX3 com 0
tmp(83) := "00001" & "000" & '0' & x"04";	-- LDR R0, @4
tmp(84) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(85) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(86) := "00111" & "000" & '0' & x"5A";	-- Se for 10, pula para a casa das centenas de milhares. Senão, atualiza o HEX4 com o próximo valor *************
tmp(87) := "00101" & "000" & '0' & x"04";	-- Armazena valor incrementado
tmp(88) := "00101" & "000" & '1' & x"24";	-- Carrega HEX4 com novo valor
tmp(89) := "01010" & "000" & '0' & x"00";	-- RET
tmp(90) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(91) := "00101" & "000" & '0' & x"04";	-- STR R0, @4
tmp(92) := "00101" & "000" & '1' & x"24";	-- Carrega HEX4 com 0
tmp(93) := "00001" & "000" & '0' & x"05";	-- LDR R0, @5
tmp(94) := "00010" & "000" & '0' & x"13";	-- Soma com constante 1
tmp(95) := "01000" & "000" & '0' & x"14";	-- Compara com a constante 10 para verificar o "vai 1"
tmp(96) := "00111" & "000" & '0' & x"64";	-- Se for 10, ativa LED de OVERFLOW e flag de inibir contagem. Senão, atualiza o HEX5 com o próximo valor *************
tmp(97) := "00101" & "000" & '0' & x"05";	-- Armazena valor incrementado
tmp(98) := "00101" & "000" & '1' & x"25";	-- Carrega HEX5 com novo valor
tmp(99) := "01010" & "000" & '0' & x"00";	-- RET
tmp(100) := "00100" & "000" & '0' & x"01";	-- LDI R0, $1
tmp(101) := "00101" & "000" & '1' & x"02";	-- Ativando LED de OVERFLOW (LDR9)
tmp(102) := "00101" & "000" & '0' & x"15";	-- STR R0, @21
tmp(103) := "01010" & "000" & '0' & x"00";	-- RET
tmp(104) := "00001" & "000" & '1' & x"64";	-- LEITURA DO FPGA_RESET
tmp(105) := "01000" & "000" & '0' & x"12";	-- CEQ R0, @18
tmp(106) := "00111" & "000" & '0' & x"23";	-- Se não foi pressionado, permanece no loop e volta para o inicio *************
tmp(107) := "01001" & "000" & '0' & x"6E";	-- Se foi pressionado, entra na subrotina de reset  *************
tmp(108) := "00000" & "000" & '0' & x"00";	-- NOP
tmp(109) := "00110" & "000" & '0' & x"23";	-- JMP @35
tmp(110) := "00101" & "000" & '1' & x"FE";	-- STR R0, @510
tmp(111) := "00100" & "000" & '0' & x"00";	-- LDI R0, $0
tmp(112) := "00101" & "000" & '0' & x"00";	-- STR R0, @0
tmp(113) := "00101" & "000" & '0' & x"01";	-- STR R0, @1
tmp(114) := "00101" & "000" & '0' & x"02";	-- STR R0, @2
tmp(115) := "00101" & "000" & '0' & x"03";	-- STR R0, @3
tmp(116) := "00101" & "000" & '0' & x"04";	-- STR R0, @4
tmp(117) := "00101" & "000" & '0' & x"05";	-- STR R0, @5
tmp(118) := "00101" & "000" & '1' & x"20";	-- STR R0, @288
tmp(119) := "00101" & "000" & '1' & x"21";	-- STR R0, @289
tmp(120) := "00101" & "000" & '1' & x"22";	-- STR R0, @290
tmp(121) := "00101" & "000" & '1' & x"23";	-- STR R0, @291
tmp(122) := "00101" & "000" & '1' & x"24";	-- STR R0, @292
tmp(123) := "00101" & "000" & '1' & x"25";	-- STR R0, @293
tmp(124) := "00101" & "000" & '1' & x"00";	-- STR R0, @256
tmp(125) := "00101" & "000" & '1' & x"01";	-- STR R0, @257
tmp(126) := "00101" & "000" & '1' & x"02";	-- STR R0, @258
tmp(127) := "01010" & "000" & '0' & x"00";	-- RET
